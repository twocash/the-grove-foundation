// src/core/copilot/patch-generator.ts
// Generate JSON patches from parsed intents

import type { ParsedIntent, JsonPatch } from './schema';
import type { GroveObject } from '@core/schema/grove-object';

/**
 * Map of common field names to JSON paths
 */
const FIELD_PATH_MAP: Record<string, string> = {
  // Meta fields
  title: '/meta/title',
  description: '/meta/description',
  icon: '/meta/icon',
  color: '/meta/color',
  status: '/meta/status',
  favorite: '/meta/favorite',
  // Common payload aliases
  duration: '/payload/estimatedMinutes',
  time: '/payload/estimatedMinutes',
  minutes: '/payload/estimatedMinutes',
  tone: '/payload/toneGuidance',
  vocabulary: '/payload/vocabularyLevel',
};

/**
 * Get a value from an object using JSON pointer path
 */
export function getValueAtPath(obj: unknown, path: string): unknown {
  const parts = path.split('/').filter(Boolean);
  let current: unknown = obj;

  for (const part of parts) {
    if (current === null || current === undefined) return undefined;
    if (typeof current !== 'object') return undefined;
    current = (current as Record<string, unknown>)[part];
  }

  return current;
}

/**
 * Apply a modifier to a string value (placeholder for real model)
 */
function applyModifier(currentValue: unknown, modifier: string): string {
  const str = String(currentValue || '');

  // Placeholder implementations - real model would do better
  if (modifier === 'shorter') {
    // Truncate to ~half
    const words = str.split(' ');
    return words.slice(0, Math.ceil(words.length / 2)).join(' ') + '...';
  }

  if (modifier === 'longer') {
    return str + ' [Extended content would be generated by model]';
  }

  if (modifier.startsWith('more ')) {
    const quality = modifier.replace('more ', '');
    return `[A more ${quality} version of: "${str}"]`;
  }

  return str;
}

/**
 * Generate a JSON patch from a parsed intent
 */
export function generatePatch(
  intent: ParsedIntent,
  object: GroveObject
): JsonPatch {
  switch (intent.type) {
    case 'SET_FIELD': {
      const path = FIELD_PATH_MAP[intent.field!] || `/meta/${intent.field}`;
      return [{ op: 'replace', path, value: intent.value }];
    }

    case 'UPDATE_FIELD': {
      const path = FIELD_PATH_MAP[intent.field!] || `/meta/${intent.field}`;
      const currentValue = getValueAtPath(object, path);
      const newValue = applyModifier(currentValue, intent.modifier!);
      return [{ op: 'replace', path, value: newValue }];
    }

    case 'ADD_TAG': {
      const currentTags = object.meta.tags || [];
      // Check if tag already exists
      if (currentTags.includes(String(intent.value))) {
        return []; // No-op
      }
      return [{ op: 'add', path: '/meta/tags/-', value: intent.value }];
    }

    case 'REMOVE_TAG': {
      const tags = object.meta.tags || [];
      const index = tags.indexOf(String(intent.value));
      if (index === -1) return []; // Tag not found
      return [{ op: 'remove', path: `/meta/tags/${index}` }];
    }

    case 'TOGGLE_FAVORITE': {
      return [{ op: 'replace', path: '/meta/favorite', value: intent.value }];
    }

    default:
      return [];
  }
}

/**
 * Get field name from path for display
 */
export function getFieldNameFromPath(path: string): string {
  const parts = path.split('/').filter(Boolean);
  return parts[parts.length - 1] || path;
}
