// src/explore/services/research-results-processor.ts
// Results Processor - Populates sprout with research results
// Sprint: sprout-research-v1, Phase 5c
//
// This service takes execution results from the Research Agent
// and populates the sprout with evidence, synthesis, and status updates.

import type {
  ResearchSprout,
  ResearchSproutStatus,
} from '@core/schema/research-sprout';
import type {
  ResearchBranch,
  Evidence,
} from '@core/schema/research-strategy';
import type { ResearchExecutionResult } from './research-agent';

// =============================================================================
// Types
// =============================================================================

/**
 * Synthesis result from evidence analysis
 */
export interface SynthesisResult {
  /** Summary of all findings */
  summary: string;

  /** Key insights extracted */
  insights: string[];

  /** Overall confidence score (0-1) */
  confidence: number;

  /** Whether manual review is recommended */
  requiresReview: boolean;
}

/**
 * Callback to update sprout in context
 */
export type UpdateSproutFn = (
  id: string,
  updates: Partial<ResearchSprout>
) => Promise<ResearchSprout>;

/**
 * Callback to transition sprout status
 */
export type TransitionStatusFn = (
  id: string,
  newStatus: ResearchSproutStatus,
  reason: string,
  actor?: string
) => Promise<ResearchSprout>;

/**
 * Results processor configuration
 */
export interface ResultsProcessorConfig {
  /** Minimum confidence for auto-completion (default: 0.6) */
  minConfidenceForAutoComplete?: number;

  /** Whether to auto-synthesize results (default: true) */
  autoSynthesize?: boolean;

  /** Agent ID for status transitions (default: 'results-processor') */
  agentId?: string;
}

/**
 * Processed results
 */
export interface ProcessedResults {
  /** Updated sprout with results */
  sprout: ResearchSprout;

  /** Generated synthesis */
  synthesis: SynthesisResult;

  /** Final status */
  status: ResearchSproutStatus;
}

// =============================================================================
// Default Configuration
// =============================================================================

const DEFAULT_CONFIG: Required<ResultsProcessorConfig> = {
  minConfidenceForAutoComplete: 0.6,
  autoSynthesize: true,
  agentId: 'results-processor',
};

// =============================================================================
// Synthesis Generation
// =============================================================================

/**
 * Generate a synthesis from collected evidence
 * In production, this would use an LLM to analyze and summarize
 */
export function generateSynthesis(
  sprout: ResearchSprout,
  branches: ResearchBranch[],
  evidence: Evidence[]
): SynthesisResult {
  // Calculate overall confidence from evidence
  const avgConfidence = evidence.length > 0
    ? evidence.reduce((sum, e) => sum + e.confidence, 0) / evidence.length
    : 0;

  const avgRelevance = evidence.length > 0
    ? evidence.reduce((sum, e) => sum + e.relevance, 0) / evidence.length
    : 0;

  // Generate summary based on evidence
  const summary = generateSummary(sprout, branches, evidence);

  // Extract insights from evidence
  const insights = extractInsights(branches, evidence);

  // Determine if review is needed
  const requiresReview = avgConfidence < 0.7 || avgRelevance < 0.7;

  return {
    summary,
    insights,
    confidence: avgConfidence,
    requiresReview,
  };
}

/**
 * Generate a summary from the research
 */
function generateSummary(
  sprout: ResearchSprout,
  branches: ResearchBranch[],
  evidence: Evidence[]
): string {
  const branchCount = branches.length;
  const evidenceCount = evidence.length;
  const completedBranches = branches.filter(b => b.status === 'complete').length;

  // In production, this would be generated by an LLM
  // For MVP, generate a structured summary
  return `Research Summary for: "${sprout.spark}"\n\n` +
    `Completed ${completedBranches}/${branchCount} research branches, ` +
    `collecting ${evidenceCount} pieces of evidence.\n\n` +
    `Branches explored:\n` +
    branches.map(b => `- ${b.label} (${b.evidence?.length ?? 0} evidence items)`).join('\n') +
    `\n\n` +
    `Evidence sources include: ` +
    [...new Set(evidence.map(e => e.sourceType))].join(', ') +
    `.\n\n` +
    `[This summary would be expanded by LLM analysis in production.]`;
}

/**
 * Extract key insights from evidence
 */
function extractInsights(
  branches: ResearchBranch[],
  evidence: Evidence[]
): string[] {
  const insights: string[] = [];

  // In production, LLM would extract actual insights
  // For MVP, generate placeholder insights based on branches

  for (const branch of branches) {
    if (branch.evidence && branch.evidence.length > 0) {
      const topEvidence = branch.evidence
        .sort((a, b) => b.relevance - a.relevance)
        .slice(0, 2);

      for (const ev of topEvidence) {
        insights.push(
          `[${branch.label}] Found ${ev.sourceType} evidence with ` +
          `${(ev.relevance * 100).toFixed(0)}% relevance`
        );
      }
    }
  }

  // Add meta-insight
  if (evidence.length > 0) {
    const avgConfidence = evidence.reduce((s, e) => s + e.confidence, 0) / evidence.length;
    insights.push(
      `Overall research confidence: ${(avgConfidence * 100).toFixed(0)}%`
    );
  }

  return insights;
}

// =============================================================================
// Results Processor
// =============================================================================

/**
 * Process execution results and update sprout
 *
 * @param sprout - The sprout being processed
 * @param executionResult - Results from Research Agent
 * @param updateSprout - Function to update sprout in context
 * @param transitionStatus - Function to transition sprout status
 * @param config - Processor configuration
 */
export async function processResults(
  sprout: ResearchSprout,
  executionResult: ResearchExecutionResult,
  updateSprout: UpdateSproutFn,
  transitionStatus: TransitionStatusFn,
  config: ResultsProcessorConfig = {}
): Promise<ProcessedResults> {
  const cfg: Required<ResultsProcessorConfig> = {
    ...DEFAULT_CONFIG,
    ...config,
  };

  const { branches, evidence, execution } = executionResult;

  // Generate synthesis
  const synthesis = cfg.autoSynthesize
    ? generateSynthesis(sprout, branches, evidence)
    : {
        summary: 'Synthesis disabled',
        insights: [],
        confidence: 0,
        requiresReview: true,
      };

  // Build updates for sprout
  const now = new Date().toISOString();
  const updates: Partial<ResearchSprout> = {
    branches,
    evidence,
    execution: {
      agentId: cfg.agentId,
      startedAt: execution.startedAt,
      completedAt: execution.completedAt,
      apiCallCount: execution.apiCallCount,
      tokenCount: execution.tokenCount,
      errorMessage: execution.errorMessage,
    },
    synthesis: {
      summary: synthesis.summary,
      insights: synthesis.insights,
      confidence: synthesis.confidence,
      synthesizedAt: now,
    },
    requiresReview: synthesis.requiresReview,
    updatedAt: now,
  };

  // Update sprout with results
  let updatedSprout = await updateSprout(sprout.id, updates);

  // Determine final status
  let finalStatus: ResearchSproutStatus;

  if (!executionResult.success) {
    // Execution failed - mark as blocked
    finalStatus = 'blocked';
    updatedSprout = await transitionStatus(
      sprout.id,
      'blocked',
      execution.errorMessage || 'Research execution failed',
      cfg.agentId
    );
  } else if (synthesis.requiresReview) {
    // Low confidence - mark completed but flag for review
    finalStatus = 'completed';
    updatedSprout = await transitionStatus(
      sprout.id,
      'completed',
      'Research completed - manual review recommended',
      cfg.agentId
    );
  } else {
    // High confidence - mark completed
    finalStatus = 'completed';
    updatedSprout = await transitionStatus(
      sprout.id,
      'completed',
      'Research completed successfully',
      cfg.agentId
    );
  }

  return {
    sprout: updatedSprout,
    synthesis,
    status: finalStatus,
  };
}

// =============================================================================
// Convenience Functions
// =============================================================================

/**
 * Check if a sprout has sufficient evidence
 */
export function hasMinimumEvidence(
  sprout: ResearchSprout,
  minEvidence: number = 1
): boolean {
  return sprout.evidence.length >= minEvidence;
}

/**
 * Calculate overall confidence for a sprout
 */
export function calculateOverallConfidence(sprout: ResearchSprout): number {
  if (sprout.evidence.length === 0) return 0;

  return sprout.evidence.reduce((sum, e) => sum + e.confidence, 0) /
    sprout.evidence.length;
}

/**
 * Get evidence grouped by source type
 */
export function getEvidenceBySourceType(
  sprout: ResearchSprout
): Record<string, Evidence[]> {
  const grouped: Record<string, Evidence[]> = {};

  for (const evidence of sprout.evidence) {
    if (!grouped[evidence.sourceType]) {
      grouped[evidence.sourceType] = [];
    }
    grouped[evidence.sourceType].push(evidence);
  }

  return grouped;
}

// =============================================================================
// Exports
// =============================================================================

export type {
  SynthesisResult,
  UpdateSproutFn,
  ResultsProcessorConfig,
  ProcessedResults,
};
